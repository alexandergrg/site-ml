
---
title: "Regresi√≥n"
format:
  html:
    code-fold: true
    toc: true
    number-sections: true
    df-print: paged
---
# üìå Introducci√≥n

El dataset **‚ÄúDatos de recaudaciones de tributos de comercio exterior‚Äù** proviene del **Servicio Nacional de Aduana del Ecuador (SENAE)** y est√° disponible en el portal oficial de [Datos Abiertos Ecuador](https://datosabiertos.gob.ec/dataset/datos-de-recaudaciones-de-tributos-de-comercio-exterior/resource/abc336cc-632c-467a-bc71-a8f5b61284e3).

Este conjunto de datos recoge informaci√≥n detallada sobre los **tributos generados por operaciones de comercio exterior** en el Ecuador, con valores de recaudaci√≥n asociados a diferentes tributos, distritos aduaneros y canales de pago.

---

## üìä Variables principales

Algunas columnas clave del dataset son:

- **NOM_DISTRITO:** Nombre del distrito aduanero donde se registr√≥ la operaci√≥n.  
- **NOM_TRIBUTO:** Tipo de tributo aplicado (ej. IVA, Arancel Advalorem, Salvaguardias).  
- **CANAL_PAGO:** Medio por el cual se realiz√≥ el pago (internet, ventanilla, tarjeta, etc.).  
- **VALOR_TOTAL_TRIBUTO_EN_NC:** Valor pagado con notas de cr√©dito.  
- **VALOR_TOTAL_TRIBUTO_EN_EFECTIVO:** Valor pagado en efectivo.  
- **VALOR_TOTAL_TRIBUTO_PAGADO:** Valor total del tributo (suma de los anteriores).  

---

## üéØ Prop√≥sito del an√°lisis

Para el **ejercicio de regresi√≥n**, nos planteamos el siguiente problema:

> **Predecir el valor total de tributos pagados (`VALOR_TOTAL_TRIBUTO_PAGADO`) en funci√≥n del distrito, el tipo de tributo y los valores parciales (nota de cr√©dito, efectivo).**

Este an√°lisis nos permitir√°:

- Identificar qu√© factores influyen m√°s en la recaudaci√≥n.  
- Evaluar la capacidad predictiva de un modelo de regresi√≥n en este contexto.  
- Demostrar un flujo completo de *Machine Learning supervisado* con **Scikit-learn Pipeline** (preprocesamiento, entrenamiento, m√©tricas y visualizaciones).  

# Carga y Exploraci√≥n Inicial

## Librer√≠as


```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split as tts
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, ConfusionMatrixDisplay
import altair as alt
```

## Carga del dataset

```{python}

df = pd.read_csv("/Users/usr-s3c/Documents/Maestria_YTech/Machine-Learning/db/senae.csv", sep="|", encoding="utf-8")
df.info()
df.head()
```

### Revisi√≥n de valores nulos y estad√≠sticos

```{python}
df.isna().sum()
```

```{python}
df.describe()
```

### Preprocesamiento 
```{python}
# Selecci√≥n de columnas (simplificado)
num_features = ["VALOR_TOTAL_TRIBUTO_EN_NC", "VALOR_TOTAL_TRIBUTO_EN_EFECTIVO"]
cat_features = ["NOM_DISTRITO", "CANAL_PAGO"]
```



```{python}
# Mapeo manual de distritos
map_distrito = {
    "028-GUAYAQUIL - MARITIMO": 1,
    "019-GUAYAQUIL - AEREO": 2,
    "055-QUITO": 3,
    "073-TULCAN": 4,
    "082-HUAQUILLAS": 5,
    "091-CUENCA": 6,
    "037-MANTA": 7,
    "064-PUERTO BOLIVAR": 8,
    "136-GERENCIA GENERAL": 9,
    "109-LOJA - MACARA": 10,
    "145-CEBAF SAN MIGUEL": 11,
    "046-ESMERALDAS": 12,
    "127-LATACUNGA": 13
}

# Mapeo manual de canales de pago
map_canal = {
    "3 -INTERNET": 1,
    " 11-SIN CANAL": 2,
    "2 -OTROS DISPOSITIVOS": 3,
    "1 -VENTANILLA": 4,
    "9 -TARJETA CREDITO": 5,
    "7 -PAGO EN LINEA": 6,
    "8 -DEBITO AUTOMATICO": 7,
    " 12-OTROS": 8
}

```

```{python}
# Crear nuevas columnas num√©ricas
df["DISTRITO_ID"] = df["NOM_DISTRITO"].map(map_distrito)
df["CANAL_ID"] = df["CANAL_PAGO"].map(map_canal)

# Revisar los resultados
df[["NOM_DISTRITO", "DISTRITO_ID", "CANAL_PAGO", "CANAL_ID"]].head(20)
```


```{python}
# Variables num√©ricas y categ√≥ricas codificadas
X = df[["DISTRITO_ID", "CANAL_ID","VALOR_TOTAL_TRIBUTO_EN_NC", "VALOR_TOTAL_TRIBUTO_EN_EFECTIVO"]]
y = df["VALOR_TOTAL_TRIBUTO_PAGADO"]

df.head(10)
```


```{python}
X_train, X_test, y_train, y_test = tts(
    X, y, test_size=0.2, random_state=42
)


```


```{python}
pipe = Pipeline([
    ("escalado", StandardScaler()),
    ("logreg",LinearRegression( n_jobs=-1))
])
```



## Entrenar el modelo

```{python}
pipe.fit(X_train, y_train)
```




```{python}
y_pred = pipe.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
r2  = r2_score(y_test, y_pred)

print(f"MSE: {mse:,.2f}")
print(f"R¬≤ : {r2:.4f}")
```



### üü¶ 1Ô∏è‚É£ Gr√°fico: Reales vs. Predichos

En esta gr√°fica, los puntos azules se alinean exactamente sobre la l√≠nea diagonal roja.  
Esto refleja que las predicciones del modelo son **id√©nticas** a los valores reales de recaudaci√≥n.

- **MSE = 0.00** ‚Üí significa que **no existe diferencia** entre los valores reales y los predichos; el error cuadr√°tico medio es nulo.  
- **R¬≤ = 1.00** ‚Üí indica que el modelo explica **el 100 % de la variabilidad** del valor total del tributo.


```{python}
alt.data_transformers.disable_max_rows()

df_pred = pd.DataFrame({
    "Real": pd.Series(y_test).astype(float).values,
    "Predicho": pd.Series(y_pred).astype(float).values
})

minv = float(min(df_pred["Real"].min(), df_pred["Predicho"].min()))
maxv = float(max(df_pred["Real"].max(), df_pred["Predicho"].max()))

scatter = (
    alt.Chart(df_pred)
    .mark_circle(size=60, opacity=0.5, color="steelblue")
    .encode(
        x=alt.X("Real:Q", title="Valor Real"),
        y=alt.Y("Predicho:Q", title="Predicci√≥n"),
        tooltip=["Real:Q","Predicho:Q"]
    )
    .properties(width=400, height=400, title="Reales vs. Predichos (Regresi√≥n SENAE)")
)

ref_df = pd.DataFrame({"Real":[minv,maxv], "Predicho":[minv,maxv]})
linea = alt.Chart(ref_df).mark_line(color="red", strokeDash=[5,5]).encode(
    x="Real:Q", y="Predicho:Q"
)

scatter + linea
```

### üüß 2Ô∏è‚É£ Gr√°fico: Curva de Aprendizaje (R¬≤)

En esta gr√°fica, las curvas de entrenamiento (R¬≤_train) y validaci√≥n (R¬≤_val)  
se mantienen **planas y constantes en 1.0** a lo largo de todos los tama√±os de muestra.

- **MSE = 0.00** en cada subconjunto ‚Üí el modelo comete **cero error** sin importar cu√°ntos datos use.  
- **R¬≤ = 1.00** en todas las etapas ‚Üí el desempe√±o es **perfecto y estable** desde el inicio del entrenamiento.

En la curva de aprendizaje se observa solo una l√≠nea (color naranja), 
porque los valores de R¬≤ en entrenamiento y validaci√≥n son id√©nticos (1.0).  
Esto ocurre debido a que el modelo reproduce una relaci√≥n exacta entre las variables, 
por lo que ambas curvas se superponen completamente. 


```{python}
## 7) Visualizaci√≥n 2 ‚Äî Curva de aprendizaje (Altair)

import numpy as np
from sklearn.model_selection import learning_curve

train_sizes, train_scores, test_scores = learning_curve(
    pipe, X, y, cv=5, scoring="r2",
    train_sizes=np.linspace(0.1, 1.0, 8), n_jobs=-1
)

df_lc = pd.DataFrame({
    "train_size": train_sizes,
    "R2_train": train_scores.mean(axis=1),
    "R2_val":   test_scores.mean(axis=1)
})
df_long = df_lc.melt(id_vars="train_size", value_vars=["R2_train","R2_val"],
                     var_name="Conjunto", value_name="R2")

alt.Chart(df_long).mark_line(point=True).encode(
    x=alt.X("train_size:Q", title="Tama√±o de entrenamiento"),
    y=alt.Y("R2:Q", title="R¬≤"),
    color=alt.Color("Conjunto:N", title=""),
    tooltip=["train_size:Q","Conjunto:N","R2:Q"]
).properties(width=400, height=400, title="Curva de aprendizaje (R¬≤)").interactive()
```

### üß† Interpretaci√≥n del modelo

El modelo de **Regresi√≥n Lineal** logr√≥ un desempe√±o **perfecto**  
(**R¬≤ = 1.0**, **MSE = 0**) porque la estructura de los datos del **SENAE** presenta una **relaci√≥n completamente lineal y determin√≠stica** entre las variables.

En el dataset, el campo **`VALOR_TOTAL_TRIBUTO_PAGADO`** se obtiene directamente como la **suma exacta** de los valores parciales:

> `VALOR_TOTAL_TRIBUTO_PAGADO = VALOR_TOTAL_TRIBUTO_EN_NC + VALOR_TOTAL_TRIBUTO_EN_EFECTIVO`

Por esta raz√≥n, el modelo ajusta los datos sin error, generando predicciones id√©nticas a los valores reales.