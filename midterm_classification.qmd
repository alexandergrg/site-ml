
---
title: "Clasificaci√≥n"
format:
  html:
    code-fold: true
    toc: true
    number-sections: true
    df-print: paged
---
# ü¶† Introducci√≥n al dataset ‚Äî Casos COVID-19 (MSP Ecuador)

El conjunto de datos **‚ÄúCasos COVID-19‚Äù**, publicado por el **Ministerio de Salud P√∫blica del Ecuador (MSP)**, recopila los registros oficiales de casos de **SARS-CoV-2** notificados entre **febrero de 2020 y marzo de 2022**.  

Cada fila representa un **caso epidemiol√≥gico individual**, con datos sobre edad, sexo, provincia, fechas de atenci√≥n y resultado final del paciente.

> üí° **Importancia del dataset**
>
> - üìä Analiza la evoluci√≥n de la pandemia en Ecuador.  
> - üßç‚Äç‚ôÇÔ∏è Permite estudiar factores asociados a hospitalizaci√≥n o fallecimiento.  
> - ü§ñ Ideal para aplicar **modelos supervisados** (clasificaci√≥n / regresi√≥n) en salud p√∫blica.

---

## ‚öôÔ∏è Caracter√≠sticas t√©cnicas

| üóÇÔ∏è **Aspecto** | **Detalle** |
|----------------|-------------|
| **Fuente** | [Datos Abiertos Ecuador ‚Äî MSP](https://datosabiertos.gob.ec/dataset/https-almacenamiento-msp-gob-ec-index-php-s-maihh1064vskrbl/resource/4a15d681-743f-493c-8133-4b88715f9947) |
| **Entidad responsable** | Direcci√≥n Nacional de Vigilancia Epidemiol√≥gica, MSP |
| **Formato** | CSV (valores separados por comas) |
| **Cobertura temporal** | Febrero 2020 ‚Äì Marzo 2022 |
| **Licencia** | Creative Commons Atribuci√≥n (CC-BY) |
| **√öltima actualizaci√≥n** | 13 de diciembre de 2022 |

---

## üßæ Campos principales del dataset

| üè∑Ô∏è **Campo** | üìñ **Descripci√≥n** | ‚öôÔ∏è **Uso** |
|--------------|------------------|-------------|
| `anio_notificacion`, `mes_notificacion`, `dia_notificacion` | Fecha en la que se notific√≥ el caso. | Variables num√©ricas predictoras. |
| `anio_atencion`, `mes_atencion`, `dia_atencion` | Fecha de atenci√≥n m√©dica. | Predictores temporales. |
| `edad_paciente` | Edad del paciente al momento de la atenci√≥n. | Variable clave num√©rica. |
| `sexo_paciente` | Sexo del paciente (HOMBRE/MUJER). | Puede binarizarse si se usa. |
| `condicion_final` | Estado final: **VIVO / MUERTO**. | üéØ **Variable objetivo (y)**. |
| `ae_se_notificacion` | Semana epidemiol√≥gica del a√±o. | Control temporal opcional. |

---

## üî¢ Variables seleccionadas para el modelo

**Predictores (X):**
- `anio_notificacion`, `mes_notificacion`, `dia_notificacion`  
- `anio_atencion`, `mes_atencion`, `dia_atencion`  
- `edad_paciente`  
- `ae_se_notificacion`  

**Variable objetivo (y):**
- `condicion_final` ‚Üí `0 = VIVO`, `1 = MUERTO`

---

## üß† Justificaci√≥n

El modelo busca **predecir la condici√≥n final del paciente** (supervivencia o fallecimiento) a partir de variables **num√©ricas** relacionadas con edad y tiempo de atenci√≥n.  
Se excluyen variables categ√≥ricas para cumplir la r√∫brica del proyecto y mantener un flujo de **clasificaci√≥n binaria limpia y reproducible**.

---

# Procesamiento de datos


```{python}
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split as tts
from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, ConfusionMatrixDisplay
import altair as alt
from sklearn.metrics import roc_curve, roc_auc_score
```

## Carga del dataset

```{python}

df = pd.read_csv("/Users/usr-s3c/Documents/Maestria_YTech/Machine-Learning/db/covid2.csv", encoding="utf-8")
df.info()
df.head()
```



### Revisi√≥n de valores nulos y estad√≠sticos

```{python}
df.isna().sum()
```

```{python}
df.describe()
```

### Preprocesamiento 


```{python}
# üîç Seleccionar solo las columnas necesarias para clasificaci√≥n
cols_relevantes = [
    "anio_atencion", "mes_atencion","edad_paciente","clasificacion_final", "condicion_final"
]
df = df[cols_relevantes].copy()
print(f"Columnas seleccionadas: {list(df.columns)}")
df.head()
```

### Resumen del preprocesamiento

En esta etapa se realiza la limpieza inicial de los datos con el objetivo de preparar las variables para el modelo de clasificaci√≥n:

- **Estandarizaci√≥n de texto:**  
  Se convierten a min√∫sculas y se eliminan espacios en blanco en las columnas `clasificacion_final` y `condicion_final`, garantizando consistencia en los valores.

- **Filtrado de registros v√°lidos:**  
  Solo se conservan los casos con clasificaci√≥n epidemiol√≥gica reconocida: `confirmado`, `probable` o `descartado`.

- **Creaci√≥n de la variable objetivo:**  
  Se transforma `condicion_final` en una variable binaria:  
  `0 = vivo` y `1 = muerto`.

- **Limpieza de valores nulos:**  
  Se eliminan los registros sin etiqueta v√°lida o con datos incompletos en la variable objetivo.

- **Conversi√≥n de tipo:**  
  Finalmente, la columna `condicion_final` se convierte al tipo entero (`int`), dej√°ndola lista para el entrenamiento del modelo.

> üí° Con este proceso, el dataset queda estandarizado, limpio y con una **variable objetivo binaria** adecuada para aplicar un modelo de **clasificaci√≥n supervisada**.

```{python}
# Normalizamos los textos a min√∫sculas sin espacios extra
df["clasificacion_final"] = df["clasificacion_final"].str.strip().str.lower()
df["condicion_final"] = df["condicion_final"].str.strip().str.lower()

# üî∏ Filtrar solo registros v√°lidos de clasificaci√≥n (descartado, confirmado, probable)
# Convertir valores de texto a n√∫meros
df["clasificacion_final"] = df["clasificacion_final"].map({
    "confirmado": 2,
    "probable": 1,
    "descartado": 0
})

# üî∏ Mapear la variable objetivo: 1 = muerto, 0 = vivo
df["condicion_final"] = df["condicion_final"].map({"vivo": 0, "muerto": 1})

# üî∏ Eliminar filas sin etiqueta v√°lida
df = df.dropna(subset=["condicion_final"])

# üî∏ Convertir tipo a entero
df["condicion_final"] = df["condicion_final"].astype(int)

print("Distribuci√≥n de la variable objetivo:")
print(df["condicion_final"].value_counts())

df.head(10)
```

### Selecci√≥n de campos para el Dataset

```{python}
# Variable objetivo
X = df[["anio_atencion", "mes_atencion", "edad_paciente", "clasificacion_final"]]
y = df["condicion_final"]

X = X.dropna()
y = y.loc[X.index]


print("Dimensiones de los conjuntos:")
print(f"X ‚Üí {X.shape[0]} filas √ó {X.shape[1]} columnas")
print(f"y ‚Üí {y.shape[0]} etiquetas")
X.head()
y
```
## Divisi√≥n de datos Train y Test

```{python}
X_train, X_test, y_train, y_test = tts(
    X,y,test_size=0.2, random_state=42,stratify=y
)
print("X_train")
print(X_train)
print("X_test")
print(X_test)


print("Y_train")
print(y_train)
print("y_test")
print(y_test)
```


##  Pipeline
```{python}
pipe = Pipeline([
    ("escalado", StandardScaler()),
    ("logreg",LogisticRegression(max_iter=1000000))
])
```

## Entrenar el modelo

```{python}
pipe.fit(X_train,y_train)
```

## Predicci√≥n

```{python}
y_pred_pipe= pipe.predict(X_test)

```

## Evaluaci√≥n

```{python}
accuracy= accuracy_score(y_test,y_pred_pipe)
precision=precision_score(y_test,y_pred_pipe)
recall=recall_score(y_test,y_pred_pipe)
f1=f1_score(y_test,y_pred_pipe)

print(f"Accuracy : ",accuracy)
print("precision :",precision)
print("recall :",recall)
print("f1 :", f1)

```

## Matriz de confusion


### üìä An√°lisis

- **Verdaderos Negativos (57 762):**  
  Casos correctamente clasificados como *vivos*.  
  Representan la gran mayor√≠a de los registros, lo que muestra que el modelo identifica correctamente a los pacientes que no fallecieron.

- **Falsos Positivos (105):**  
  Casos predichos como *muertos* cuando en realidad estaban *vivos*.  
  Son pocos, lo que indica un **bajo nivel de alarmas falsas**.

- **Falsos Negativos (1 594):**  
  Casos reales de *muertos* que el modelo clasific√≥ como *vivos*.  
  Este valor es relativamente alto en proporci√≥n a los positivos reales, lo que sugiere que el modelo **tiende a subestimar los casos cr√≠ticos** (bajo *recall* para la clase 1).

- **Verdaderos Positivos (67):**  
  Casos correctamente identificados como *muertos*.  
  Aunque son pocos, muestran que el modelo tiene cierta capacidad de detecci√≥n de la clase minoritaria.

---

### üìà Conclusi√≥n

El modelo logra un **excelente desempe√±o general (alta precisi√≥n global)**, pero presenta **desbalance de clases**: la mayor√≠a de los pacientes son *vivos*, y los casos *muertos* son escasos.

```{python}
ConfusionMatrixDisplay.from_predictions(y_test,y_pred_pipe)
```


### üìà Interpretaci√≥n de la Curva ROC

La **curva ROC (Receiver Operating Characteristic)** muestra la relaci√≥n entre la **tasa de verdaderos positivos (TPR)** y la **tasa de falsos positivos (FPR)** a diferentes umbrales de decisi√≥n.

- La l√≠nea roja discontinua representa un **modelo aleatorio** (sin poder de discriminaci√≥n).  
- La curva azul, correspondiente al modelo de regresi√≥n log√≠stica, se eleva muy por encima de esta l√≠nea.  
- El valor **AUC = 0.902** indica una **alta capacidad de clasificaci√≥n**, lo que significa que el modelo distingue correctamente entre los pacientes **vivos (0)** y **muertos (1)** en m√°s del **90% de los casos**.

> ‚úÖ En t√©rminos pr√°cticos:  
> El modelo tiene un desempe√±o excelente y generaliza bien; sin embargo, se recomienda revisar el balance de clases y ajustar el umbral dependiedno la necesidad

```{python}

# Calcular los valores de la curva ROC
y_proba = pipe.predict_proba(X_test)[:, 1]
fpr, tpr, thr = roc_curve(y_test, y_proba)
auc = roc_auc_score(y_test, y_proba)

# Crear un DataFrame con los resultados
roc_df = pd.DataFrame({
    "FPR": fpr,
    "TPR": tpr,
    "Threshold": thr
})

# === Gr√°fico ROC con Altair ===
roc_chart = (
    alt.Chart(roc_df)
    .mark_line(color="#1f77b4", strokeWidth=3)
    .encode(
        x=alt.X("FPR", title="Tasa de falsos positivos"),
        y=alt.Y("TPR", title="Tasa de verdaderos positivos"),
        tooltip=["FPR", "TPR", "Threshold"]
    )
    .properties(
        title=f"Curva ROC (AUC = {auc:.3f})",
        width=400,
        height=300,
    ).interactive()
)

# L√≠nea diagonal de referencia (clasificador aleatorio)
ref_line = (
    alt.Chart(pd.DataFrame({"x": [0, 1], "y": [0, 1]}))
    .mark_line(strokeDash=[5, 5], color="red")
    .encode(x="x", y="y")
)

roc_chart_final = roc_chart + ref_line
roc_chart_final
```